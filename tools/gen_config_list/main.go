package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

type module struct {
	ImportPath  string
	PackageName string
	ConfigType  string
}

func main() {
	modulePath, err := readModulePath()
	if err != nil {
		log.Fatalf("failed to read go.mod: %v", err)
	}

	var modules []module

	err = filepath.Walk("pkg", func(path string, info os.FileInfo, err error) error {
		if filepath.Base(path) != "config.go" {
			return nil
		}
		if strings.Contains(path, "/testdata/") {
			return nil
		}
		if filepath.Clean(path) == filepath.Join("pkg", "config", "config.go") {
			return nil // skip self
		}

		configType, err := extractConfigType(path)
		if err != nil {
			return fmt.Errorf("error in %s: %w", path, err)
		}
		if configType == "" {
			return nil // no config type found
		}

		pkgDir := filepath.Dir(path)
		pkgImport := filepath.ToSlash(pkgDir)
		importPath := modulePath + "/" + pkgImport
		packageName := filepath.Base(pkgDir)

		modules = append(modules, module{
			ImportPath:  importPath,
			PackageName: packageName,
			ConfigType:  configType,
		})
		return nil
	})
	if err != nil {
		log.Fatal(err)
	}

	if len(modules) == 0 {
		fmt.Println("No modules found. Skipped generating pkg/config/modules.gen.go.")
		return
	}

	var buf bytes.Buffer
	buf.WriteString("// Code generated by tools/gen_config_list/main.go. DO NOT EDIT.\n\n")
	buf.WriteString("package config\n\n")

	// import block
	seen := map[string]bool{}
	var importLines []string
	for _, mod := range modules {
		if !seen[mod.ImportPath] {
			seen[mod.ImportPath] = true
			importLines = append(importLines, fmt.Sprintf("\t%q", mod.ImportPath))
		}
	}
	if len(importLines) > 0 {
		buf.WriteString("import (\n")
		for _, line := range importLines {
			buf.WriteString(line + "\n")
		}
		buf.WriteString(")\n\n")
	}

	// init() assignment to DefaultModules
	buf.WriteString("func init() {\n")
	buf.WriteString("\tconfig.DefaultModules = []config.IConfig{\n")
	for _, mod := range modules {
		buf.WriteString(fmt.Sprintf("\t\t%s.New%s(),\n", mod.PackageName, mod.ConfigType))
	}
	buf.WriteString("\t}\n")
	buf.WriteString("}\n")

	err = os.WriteFile("pkg/config/modules.gen.go", buf.Bytes(), 0644)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Generated pkg/config/modules.gen.go with %d modules.\n", len(modules))
}

// readModulePath parses the module path from go.mod
func readModulePath() (string, error) {
	f, err := os.Open("go.mod")
	if err != nil {
		return "", err
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module ")), nil
		}
	}
	return "", fmt.Errorf("module path not found in go.mod")
}

// extractConfigType returns the name of the struct that ends with 'Config'
func extractConfigType(path string) (string, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
	if err != nil {
		return "", err
	}

	for _, decl := range node.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}
		for _, spec := range gen.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			if strings.HasSuffix(typeSpec.Name.Name, "Config") {
				return typeSpec.Name.Name, nil
			}
		}
	}
	return "", nil
}
